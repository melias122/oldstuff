package main

import (
	"errors"
	"math/big"
	"time"
)

// maximum length polynomials
// for given size
var polynomials = map[int]string{
	8:    "b8",
	16:   "b400",
	32:   "80000057",
	64:   "d800000000000000",
	128:  "e1000000000000000000000000000000",
	256:  "a420000000000000000000000000000000000000000000000000000000000000",
	342:  "20000000000000000000000000000001000000000000000000000000000000000000000000000000000000",
	512:  "a4800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
	683:  "610800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
	1024: "8040030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
	2048: "80061000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
	4096: "c001001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
}

type LFSR struct {
	state *big.Int
	poly  *big.Int
}

func NewLFSR(d int) (lfsr LFSR, err error) {

	if s, ok := polynomials[d]; !ok {
		err = errors.New("LFSR: unsupported size")
	} else {
		lfsr.poly, ok = new(big.Int).SetString(s, 16)
		if !ok {
			err = errors.New("LFSR: error parsing hex")
		}
	}

	if err != nil {
		return
	}
	lfsr.Seed(nil)

	return
}

func (r *LFSR) rand(next *big.Int) *big.Int {
	bit := new(big.Int).And(r.state, bigOne) // bit = r.state & 1
	r.state.Rsh(r.state, 1)                  // r.state >>= 1
	if bit.Cmp(bigOne) == 0 {
		r.state.Xor(r.state, r.poly)
	}
	return next.Set(r.state)
}

// Seed set lfsr state to seed
// if seed is nil or zero state is set from current time
func (r *LFSR) Seed(seed *big.Int) {
	if (seed == nil) || (seed.Cmp(bigZero) == 0) {
		r.state = new(big.Int).SetInt64(time.Now().UnixNano())
	} else {
		r.state = seed
	}
	r.state.Mod(r.state, r.poly)
}

// Rand returns rand integer between <0, m)
func (r *LFSR) RandMod(m *big.Int) *big.Int {
	i := r.rand(new(big.Int))
	return i.Mod(i, m)
}

func (r *LFSR) RandInt() *big.Int {
	return r.rand(new(big.Int))
}

// NextPrime generates next prime number in sequence
func (r *LFSR) NextPrime() *big.Int {
	prime := new(big.Int)
	for {
		prime = r.rand(prime)
		if prime.ProbablyPrime(10) {
			break
		}
	}
	return prime
}

// NextPrimeBits generate next prime of given bits size
func (r *LFSR) NextPrimeBits(nbits int) *big.Int {
	prime := new(big.Int)
	for {

		// search for rand int of given bit length
		prime = r.rand(prime)
		if prime.BitLen() != nbits {
			continue
		}

		// make it odd
		prime.Or(prime, bigOne)

		// find next prime by searching odd int
		// perform 10 rabin-miller tests and make sure
		// its bitlen is what we want
		for i := 0; i < 1<<20; i++ {
			if prime.ProbablyPrime(10) && prime.BitLen() == nbits {
				return prime
			}
			prime.Add(prime, bigTwo)
		}
	}
	panic("unreachable")
}
